{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Notes on Using Divergence Functions\n",
    "\n",
    "The **mvtk.supervisor.divergence** contains several functions that compute **total variation** between two data distributions. However, these functions have very different mechanisms for arriving at total variation. Some functions, such as **calc_tv** use a neural network under the hood, while others such as **calc_tv_knn** use a different mechanism to arrive at the range of values to inform on whether two distributions are more similar or not. Because of these differences, there functions are often best suited for different circumstances, be it data size, computational resources, or accuracy requirements. This notebook provides a guide to when and how to use the functions.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import warnings\n",
    "from IPython.display import display\n",
    "from ipywidgets import HTML\n",
    "warnings.filterwarnings('ignore')\n",
    "from mvtk.supervisor.divergence import calc_tv, calc_tv_knn, calc_tv_density, calc_tv_mle, calc_kl_mle, calc_hl\n",
    "from mvtk.supervisor.utils import column_indexes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Types\n",
    "\n",
    "The algorithms underneath the divergence functions all operate on **numpy arrays**. A divergence function compares a **sample_a** vs a **sample_b**, where a sample is either an array \n",
    "\n",
    "```\n",
    "def divergence_function(sample_a, sample_b, **kwargs):\n",
    "    algorithm\n",
    "```\n",
    "**OR** a *list of arrays*\n",
    "\n",
    "```\n",
    "def divergence_function([sample_a], [sample_b], **kwargs):\n",
    "    algorithm\n",
    "```\n",
    "\n",
    "The functions that accept lists allow you to test one *list of batches* against another *list of batches*. For example,  \n",
    "```\n",
    "sample_a = [batch1, batch2, batch3] \n",
    "sample_b = [[batch5, batch6]\n",
    "```\n",
    "\n",
    "This will compare the average of the distributions that generated `batch1`, `batch2`, and `batch3` to the average of the distributions that generated `batch4` and `batch5`. You can just use singletons to compare `batch1` to `batch2`, i.e.\n",
    "```\n",
    "sample_a = [batch1] \n",
    "sample_b = [batch2]\n",
    "```\n",
    "\n",
    "For the divergence functions that you intend to use, you should check the documentation as to whether it accepts lists or arrays.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Using Dataframes\n",
    "\n",
    "Pandas dataframes are a perfect input source for the divergence functions. The underlying storage for dataframes are numpy arrays on which all divergence functions can operate.\n",
    "\n",
    "If your data is in **Pyspark** dataframes then you either convert to pandas dataframes, or numpy arrays."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>weight</th>\n",
       "      <th>colors</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>79.360725</td>\n",
       "      <td>green</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>92.373537</td>\n",
       "      <td>green</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>91.021177</td>\n",
       "      <td>green</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      weight colors\n",
       "0  79.360725  green\n",
       "1  92.373537  green\n",
       "2  91.021177  green"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "df = pd.DataFrame({'weight': np.random.uniform(1, 100, size=(10000)),\n",
    "                  'colors': np.random.choice(['red', 'blue', 'green', 'yellow'], p=[0.2, 0.3, 0.3, 0.2])})\n",
    "df.head(3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Create Data Distributions\n",
    "\n",
    "For data, we will create datasets drawn from different distributions. We will use about a **million rows**, and about **100** columns.\n",
    "\n",
    "Each row in a dataset becomes a training example to be used in the neural network that calculates the divergence. If you have too few rows, then the divergence value will not be calculated accurately, and in practice will be close to zero."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "ROWS, COLUMNS = 1000000, 10\n",
    "DATA_SHAPE = ROWS, COLUMNS"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "samples = dict()\n",
    "uniform_a   = samples['uniform_a']   = np.random.uniform(1, 100, size=DATA_SHAPE)\n",
    "uniform_b   = samples['uniform_b']   = np.random.uniform(1, 100, size=DATA_SHAPE)\n",
    "beta_a      = samples['beta_a']      = np.random.beta(0.2, 0.9, size=DATA_SHAPE)\n",
    "chisquare_a = samples['chisquare_a'] = np.random.chisquare(2,DATA_SHAPE)\n",
    "ones        = samples['ones']        = np.ones(DATA_SHAPE)\n",
    "\n",
    "funcs = {'calc_tv': calc_tv}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Visualizing the distributions\n",
    "Let's visualize each of our probability distributions. In this case, each of the `COLUMNS=10` features has exactly the same distribution and they are all independent of eachother, so the following function just lumps all of the samples together. In general, you would _not_ want to do this!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.style as style\n",
    "import seaborn as sns; sns.set()\n",
    "\n",
    "def distplot(series, title=None):\n",
    "    if isinstance(series, pd.Series):\n",
    "        series = series.values\n",
    "    sns.distplot(series.ravel())\n",
    "    plt.xticks([])\n",
    "    plt.yticks([])\n",
    "    plt.grid(False)\n",
    "    if title:\n",
    "        plt.title(title)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "distplot(uniform_a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "distplot(beta_a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "distplot(chisquare_a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAV0AAADnCAYAAAC9roUQAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjEsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+j8jraAAAED0lEQVR4nO3bvU6TYRiA4Ye2BCODYTIknoAH0NGj140DcHImTkwORGgddDAFGkng5sfrGp83TZ7hzZ0v/dqD7XY7ADQWT70AwP9EdAFCogsQEl2A0GrP2dHMrGfmfGaum3UAXrzlzJzOzNnMXO4e7ovuemY+P9JSAK/dp5n5sjvcF93zmZmLix+z2fhZGcC/WCwO5uTkeOZPQ3fti+71zMxmsxVdgPu79WtZL9IAQqILEBJdgJDoAoREFyAkugAh0QUIiS5AaN+fI+BZu9rMXP68ujE/OlzNyuMEz5To8mJd/ryas6/fb8zXH9/P6sjV5nnyPAAQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXICS6ACHRBQiJLkBIdAFCogsQEl2AkOgChEQXILTac7acmVksDqJV4H5Wy8W8fXN469y95an8dfeWt53vi+7pzMzJyfEDrwQP58Ppu6deAe5yOjPfdocH2+32rg8czcx6Zs5n5vrx9gJ4VZbzO7hnM3O5e7gvugA8MC/SAEKiCxASXYCQ6AKEfgGoCjFHOiKvJQAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "distplot(ones)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Calculating Total Variation\n",
    "The main divergence functions calculate the total variation between distributions. However, there are very different ways to arrive at a range of 0-1 with 0 meaning no divergence, and 1 meaning total divergence. This presents users with different approaches with benefits that match different circumstances and dta sizes."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## calc_tv\n",
    "Computes the total variation between two distributions.\n",
    "\n",
    "See https://en.wikipedia.org/wiki/Total_variation_distance_of_probability_measures\n",
    "It uses a neural network to calculate the total variation between distributions. Since it uses a neural network internally, it exposes some familar settings such as the num_epochs, num_batches etc. which you can tune for greater accuracy.  \n",
    "\n",
    "`sample_distribution_p` *The first distribution*\n",
    "\n",
    "`sample_distribution_q` *The second distribution*\n",
    "\n",
    "`categorical_columns` If using a dataframe, the categorical columns\n",
    "\n",
    "`num_epochs` The number of epochs to train for\n",
    "\n",
    "`num_batches`\n",
    "\n",
    "\n",
    "Additionally, you can use `model_generator_kwargs` to set `model_generator` default `**kwargs`. Of particular importance are:\n",
    "\n",
    "`depth` The number of layers of the neural network. Defaults to `3`\n",
    "\n",
    "`width` The size of the hidden layer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0004881620407104492"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv(uniform_a, uniform_b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If two distributions are different then the divergence will be close to one."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9995993375778198"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv(uniform_a, ones)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can get better accuracy by changing the default parameters - in this case **num_epochs=16, num_batches=128, depth=2, width=32**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.999308705329895"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv(uniform_a, ones, num_epochs=16, num_batches=128, model_generator_kwargs={'width': 32, 'depth': 2})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9999822974205017"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv(uniform_a, chisquare_a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9989728927612305"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv(uniform_a, [pd.DataFrame(chisquare_a), ones])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.5061822533607483"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv([uniform_a, ones],[chisquare_a])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## calc_hl\n",
    "\n",
    "Calculate divergence using Hellinger distance. \n",
    "\n",
    "See https://en.wikipedia.org/wiki/Hellinger_distance\n",
    "\n",
    "**sample_distribution_p** *The first distribution*\n",
    "\n",
    "**sample_distribution_q** *The second distribution*\n",
    "\n",
    "Additionally, you can use `model_generator_kwargs` to set `model_generator` default `**kwargs`. Of particular importance are:\n",
    "\n",
    "`depth` The number of layers of the neural network. Defaults to `3`\n",
    "\n",
    "`width` The size of the hidden layer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_hl(uniform_a, uniform_b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_hl(uniform_a, chisquare_a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**calc_hl** finds a significant divergence between the beta and chisquare distributions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9981940472630377"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_hl(beta_a, chisquare_a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## calc_tv_knn\n",
    "\n",
    "Computes the total variation between two distributions. Because it uses KNN which is a fairly simple algorithm it is often faster to compute that **calc_tv**. However, you will want to take care to set the function parameters based on your data dimensions in order for it to get the best accuracy.\n",
    "\n",
    "**sample_distribution_p** *The first distribution*\n",
    "\n",
    "**sample_distribution_q** *The second distribution*\n",
    "\n",
    "**bias**\n",
    "\n",
    "**num_samples** *Number of subsamples to take\n",
    "            from each distribution on which to construct kdtrees and\n",
    "            otherwise make computations. Defaults to 2046*\n",
    "\n",
    "**categorical_columns**\n",
    "\n",
    "**k** *number of nearest neighbours. As a rule of\n",
    "            thumb, you should multiply this by two with every dimension\n",
    "            past one. Defaults to 128*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here is an example of using the default parameters for **calc_tv_knn** on similar distributions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.03465665858242252"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_knn(uniform_a, uniform_b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this example, **calc_tv_knn** picks up a divergence between the **uniform** and **beta** distributions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.8272527964149479"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_knn(uniform_a, beta_a, k=20)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "and between the uniform and chisquare distributions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9306603225843605"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_knn(uniform_a, chisquare_a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**KNN** is an unbiased estimator and will sometimes overshoot. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.20928344516188"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_knn(beta_a, chisquare_a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "One way to address this is to set the value of **k neighbours** to **2 * the number of dimensions**. There are 10 columns so we set k to **20**."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.1124090464149479"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_knn(beta_a, chisquare_a, k = 20)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.07457887528399548"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_knn(beta_a, beta_a, k=20)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Density Based Estimators\n",
    "\n",
    "Density estimation is the problem of reconstructing the probability density function using a set of given data\n",
    "points."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## calc_tv_density"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "165011946.1532011"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_density(uniform_a, uniform_b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "251557894.78209227"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_density(uniform_a, beta_a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Handling Categorical Data\n",
    "If your data is all categorical, then you would probably want to use **calc_tv_mle**. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For these examples, we will create categorical columns drawn from different distributions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "FRUITS, FRUIT_PROBS = ['apple', 'orange', 'plum', 'raspberry', 'blueberry'], [0.1, 0.3, 0.3, 0.25, 0.05]\n",
    "assert sum(FRUIT_PROBS) ==1\n",
    "\n",
    "raspberry_blast = np.random.choice(FRUITS,size=(1000000, 10), p=FRUIT_PROBS)\n",
    "blueberry_blast = np.random.choice(FRUITS,size=(1000000, 10), p=FRUIT_PROBS)\n",
    "plain_smoothie = np.random.choice(FRUITS, size=(1000000, 10))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## calc_tv_mle\n",
    "\n",
    "Computes the total variation between two distributions using histogram based density estimators. All\n",
    " columns are assumed to be categorical.\n",
    "\n",
    "**sample_distribution_p** *The first distribution*\n",
    "\n",
    "**sample_distribution_q** *The second distribution*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array(['orange', 'apple', 'plum', 'plum', 'plum', 'plum', 'orange',\n",
       "       'raspberry', 'plum', 'orange'], dtype='<U9')"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "raspberry_blast[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The samples **raspberry_blast** and **plain_smoothie** have been drawn from different distributions and so we expect to see a high **total variation**."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9319870000000001"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_mle(raspberry_blast, plain_smoothie)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But the samples **raspberry_blast** and **plain_smoothie** have been drawn from similar distributions and so we expect to see lower total variation.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.6263819999999999"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_mle(raspberry_blast, blueberry_blast)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## calc_kl_mle\n",
    "\n",
    "When the second distribution is zero when the first distribution is nonzero for categorical data, kl divergence will hit infinity. For histograms derived from high dimensional categorical data this becomes likely."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "inf"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_kl_mle(raspberry_blast, plain_smoothie)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Handling Mixed Data\n",
    "\n",
    "If your data contains categorical columns, then you need to specify the indices of the categorical columns. To demonstrate this, we will create a dataframe with one categorical column and one numeric column, then compute the total variation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "NUM_ITEMS = 100000\n",
    "inventory_a = pd.DataFrame({'fruits': np.random.choice(FRUITS,size=NUM_ITEMS, p=FRUIT_PROBS), \n",
    "                          'weight': np.random.uniform(1, 100, size=NUM_ITEMS).tolist()})\n",
    "\n",
    "inventory_b = pd.DataFrame({'fruits': np.random.choice(FRUITS,size=NUM_ITEMS), \n",
    "                            'weight': np.random.beta(0.2, 0.9, size=NUM_ITEMS).tolist()})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>fruits</th>\n",
       "      <th>weight</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>plum</td>\n",
       "      <td>9.043091</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>orange</td>\n",
       "      <td>82.114676</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>raspberry</td>\n",
       "      <td>31.065103</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>raspberry</td>\n",
       "      <td>64.049112</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      fruits     weight\n",
       "0       plum   9.043091\n",
       "1     orange  82.114676\n",
       "2  raspberry  31.065103\n",
       "3  raspberry  64.049112"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "inventory_a.head(4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>fruits</th>\n",
       "      <th>weight</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>plum</td>\n",
       "      <td>0.001619</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>plum</td>\n",
       "      <td>0.000238</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>raspberry</td>\n",
       "      <td>0.978383</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>orange</td>\n",
       "      <td>0.514946</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      fruits    weight\n",
       "0       plum  0.001619\n",
       "1       plum  0.000238\n",
       "2  raspberry  0.978383\n",
       "3     orange  0.514946"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "inventory_b.head(4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can use **calc_tv_knn**, setting **k=4** since there are only two columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.664169492122229"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_knn(inventory_a, inventory_b, categorical_columns=[0], k=4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you use **calc_tv_knn** on the same data you get a lower value since it's the same distribution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.216708554622229"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "calc_tv_knn(inventory_a, inventory_a, categorical_columns=[0], k=4)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
